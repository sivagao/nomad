{"data":{"mongodbDatabaseArticles":{"id":"5b93830287be056953db7e18","content":"<div><h1 name=\"8269\" id=\"8269\" class=\"graf graf--h3 graf--leading graf--title\">Pass the Remote: User Input on TV&#160;Devices</h1><p name=\"0c64\" id=\"0c64\" class=\"graf graf--p graf-after--h3\">by <a href=\"https://twitter.com/WikkaWikka\" class=\"markup--anchor markup--p-anchor\" rel=\"noopener nofollow\" target=\"_blank\">Andrew Eichacker</a></p><p name=\"c2d1\" id=\"c2d1\" class=\"graf graf--p graf-after--p\">The Netflix TV team works with device manufacturers to explore new input methods (like your phone!) and <a href=\"https://devices.netflix.com/en/recommendedtv/2017/\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">improve the screens</a> we watch our favorite shows on. Beyond that, we&#8217;re testing the boundaries for content discovery and playback while bringing Netflix to more users around the world.</p><p name=\"2242\" id=\"2242\" class=\"graf graf--p graf-after--p\">We&#8217;ve come a long way from the television dial. From simple remotes to dedicated tablets to waving hands to saying &#8220;Hi TV!&#8221;, there are a variety of ways that users interact with their TV today. For the sake of this post, we&#8217;ll keep it to the two primary input methods: standard and pointer remotes.</p><h3 name=\"6634\" id=\"6634\" class=\"graf graf--h3 graf-after--p\">Up Up Down Down Left Right Left&#160;Right&#8230;</h3><p name=\"df6e\" id=\"df6e\" class=\"graf graf--p graf-after--h3\">We use the acronym LRUD to describe input via directional controls&#8202;&#8212;&#8202;that is: <strong class=\"markup--strong markup--p-strong\">L</strong>eft, <strong class=\"markup--strong markup--p-strong\">R</strong>ight, <strong class=\"markup--strong markup--p-strong\">U</strong>p, and <strong class=\"markup--strong markup--p-strong\">D</strong>own. Of course, there is also a selection button (e.g. OK) and usually a Back button. Users navigate the screen via UI elements that can be focused via a directional key, and subsequent key events are handled with that element as the target. For web developers familiar with accessibility requirements, this might sound similar to tab order, with the additional dimension of directional navigation.</p><p name=\"ea3b\" id=\"ea3b\" class=\"graf graf--p graf-after--p\">Unlike tab order, there is no default handling by the platform&#8202;&#8212;&#8202;navigational order is defined by UI developers, as if everything has to specify a <code class=\"markup--code markup--p-code\">tabindex</code>. While it might seem simple to navigate to another element in one direction, it can be challenging to maintain order in the midst of dynamic UI layouts and AB tests. One simple approach is to use delegation to let the common parent control the flow of navigation.</p><p class=\"aspectRatioPlaceholder-fill\"></p><img class=\"graf-image\" src=\"https://cdn-images-1.medium.com/max/1600/1*xtU0fYmGc1ppbnDK1gzJIA.png\"><p name=\"3fd3\" id=\"3fd3\" class=\"graf graf--p graf-after--figure\">Working with a device that only supports LRUD is a bit different than a web/mobile app. Maintaining the correct focus for a single element is essential, as the user doesn&#8217;t have direct interaction like they do with a mouse or with touch. If focus gets in a bad state, there is no way for the user to recover by clicking or tapping around, so the user will think the app has frozen.</p><h3 name=\"87ca\" id=\"87ca\" class=\"graf graf--h3 graf-after--p\">They Say It&#8217;s Rude to&#160;Point</h3><p class=\"aspectRatioPlaceholder-fill\"></p><img class=\"graf-image\" src=\"https://cdn-images-1.medium.com/max/1600/1*Dn5xmHMBfPvjuBVW78tnGA.png\"><p name=\"ac7c\" id=\"ac7c\" class=\"graf graf--p graf-after--figure\">Some TVs support a pointer remote, which allows the user to point the remote at their TV to interact with what&#8217;s on screen. Pointer navigation should be familiar to most web developers, as it is very similar to mouse/touch input. The UX tends to parallel mouse usage more than touch, such as using a scroll wheel or arrow affordances to navigate lists instead of swiping. Due to the distance to the TV and difficulty holding the pointer still while your arm is in the air, buttons require large targets like a touch-based UI.</p><p name=\"0abd\" id=\"0abd\" class=\"graf graf--p graf-after--p\">TV pointer remotes aren&#8217;t just mice, however; they also have LRUD buttons. This has the potential to make things rather confusing for the user. If using the pointer to focus one element and LRUD navigates upward, which one remains focused&#8202;&#8212;&#8202;the element above or the one under the pointer?</p><p class=\"aspectRatioPlaceholder-fill\"></p><img class=\"graf-image\" src=\"https://cdn-images-1.medium.com/max/1600/1*8Yv1k1Oa2PxALc-5L08-3w.png\"><p name=\"51e4\" id=\"51e4\" class=\"graf graf--p graf-after--figure\">As a result, most devices have introduced modality to the remote: when using the pointer, only the pointer behavior is respected. If the user starts interacting with LRUD, the pointer is hidden and the interaction switches to LRUD only.</p><p name=\"5e40\" id=\"5e40\" class=\"graf graf--p graf-after--p\">There are a couple of things we need to do to support and reinforce this modality. When in pointer mode, focus could be lost by pointing over a non-interactive element, so we must establish a reasonable focus when switching to LRUD mode&#8202;&#8212;&#8202;either the last-focused element or some screen default. Since pointer scroll affordances only make sense for pointer mode, we hide those in LRUD mode.</p><h3 name=\"8d81\" id=\"8d81\" class=\"graf graf--h3 graf-after--p\">Building a Better Mouse (and LRUD)&#160;Trap</h3><p name=\"172c\" id=\"172c\" class=\"graf graf--p graf-after--h3\">Over time, we found that handling input was rather cumbersome. Many of our views had custom-built focus handling that broke when the composition of the screen changed, such as with features introduced by AB tests. The UX differed slightly from screen to screen for things like re-establishing focus when switching to LRUD mode or LRUD navigation in asymmetrical layouts. We had a number of bugs that we ran into repeatedly on multiple views, such as:</p><ol class=\"postList\"><li name=\"fa16\" id=\"fa16\" class=\"graf graf--li graf-after--p\">Multiple items try to focus at once, causing both to appear highlighted but with undefined behavior regarding which one will get key events</li><li name=\"0698\" id=\"0698\" class=\"graf graf--li graf-after--li\">Something behind the top-most view steals focus, causing navigation in an unseen area</li><li name=\"f4c1\" id=\"f4c1\" class=\"graf graf--li graf-after--li\">Switching between pointer/LRUD modes causes dual focus or no focus</li><li name=\"ccf7\" id=\"ccf7\" class=\"graf graf--li graf-after--li\">A focused element is removed, and nothing claims focus&#8202;&#8212;&#8202;leaving nothing focused</li></ol><p name=\"e749\" id=\"e749\" class=\"graf graf--p graf-after--li\">When we <a href=\"https://www.youtube.com/watch?v=5sETJs2_jwo\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">set out to build our app with React</a>, we wanted to craft a more robust solution for user input. We landed on 3 core systems: declarative focus, spatial navigation, and focus requests.</p><h4 name=\"7678\" id=\"7678\" class=\"graf graf--h4 graf-after--p\">Declarative Focus</h4><p name=\"db3c\" id=\"db3c\" class=\"graf graf--p graf-after--h4\">While moving to React, we tried to rethink a lot of our controls that were historically based on imperative APIs and see how we could design them to be more declarative. This also allows us to <a href=\"https://medium.com/netflix-techblog/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b\" class=\"markup--anchor markup--p-anchor\" target=\"_blank\">avoid the usage of refs</a> to imperatively focus.</p><p name=\"9aa4\" id=\"9aa4\" class=\"graf graf--p graf-after--p\">Instead of divs, our core building block is a <code class=\"markup--code markup--p-code\">Widget</code>. In order to differentiate between any widget and one that could receive focus, we created <code class=\"markup--code markup--p-code\">FocusableWidget</code>, which takes an additional 2 props:</p><ul class=\"postList\"><li name=\"c406\" id=\"c406\" class=\"graf graf--li graf-after--p\"><code class=\"markup--code markup--li-code\">focused</code><strong class=\"markup--strong markup--li-strong\">&#8202;</strong>&#8212;&#8202;boolean indicating if this widget should have focus</li><li name=\"d516\" id=\"d516\" class=\"graf graf--li graf-after--li\"><code class=\"markup--code markup--li-code\">focusKey</code>&#8202;&#8212;&#8202;used to identify the <code class=\"markup--code markup--li-code\">FocusableWidget</code> and construct a <code class=\"markup--code markup--li-code\">focusPath</code></li></ul><p name=\"3c2e\" id=\"3c2e\" class=\"graf graf--p graf-after--li\"><code class=\"markup--code markup--p-code\">FocusableWidgets</code> can be nested, giving a structure to how a <code class=\"markup--code markup--p-code\">FocusableWidget</code> relates to others. A <code class=\"markup--code markup--p-code\">focusPath</code> is just a way to signify a path from the root FocusableWidget all the way down to a leaf, e.g. &#8216;/app/menu/play&#8217;. These will come into play more with the other two systems.</p><p name=\"6433\" id=\"6433\" class=\"graf graf--p graf-after--p\">Since focus is declared as part of rendering, we can validate and apply the declared focus when rendering all elements completes. This gives us an opportunity to assert on error conditions (e.g. multiple focused widgets, nothing focused).</p><h4 name=\"130e\" id=\"130e\" class=\"graf graf--h4 graf-after--p\">Spatial Navigation</h4><p name=\"86dd\" id=\"86dd\" class=\"graf graf--p graf-after--h4\">Spatial navigation is intended to make it easier to determine what should be focused by an LRUD event without having to write custom navigation code. The idea is to identify the most-likely desired element in the direction of the key press.</p><p name=\"2d97\" id=\"2d97\" class=\"graf graf--p graf-after--p\">The primary concerns with this approach were:</p><ul class=\"postList\"><li name=\"644c\" id=\"644c\" class=\"graf graf--li graf-after--p\"><strong class=\"markup--strong markup--li-strong\">Performance</strong>&#8202;&#8212;&#8202;a <a href=\"https://medium.com/netflix-techblog/crafting-a-high-performance-tv-user-interface-using-react-3350e5a6ad3b\" class=\"markup--anchor markup--li-anchor\" target=\"_blank\">recurring</a> <a href=\"https://www.youtube.com/watch?v=5sETJs2_jwo\" class=\"markup--anchor markup--li-anchor\" rel=\"nofollow noopener\" target=\"_blank\">theme</a> <a href=\"https://medium.com/netflix-techblog/building-the-new-netflix-experience-for-tv-920d71d875de\" class=\"markup--anchor markup--li-anchor\" target=\"_blank\">for</a> us&#8202;&#8212;&#8202;how are we going to look through all of these elements quickly?</li><li name=\"8f4c\" id=\"8f4c\" class=\"graf graf--li graf-after--li\"><strong class=\"markup--strong markup--li-strong\">Correctness</strong>&#8202;&#8212;&#8202;how do we ensure the correct element is focused, even in cases where the closest element is not the correct target? We ensured spatial navigation can be interrupted so custom handling can be implemented when necessary, but we&#8217;d prefer to avoid doing that all over the place.</li></ul><p name=\"962f\" id=\"962f\" class=\"graf graf--p graf-after--li\"><strong class=\"markup--strong markup--p-strong\">Focusable Tree<br></strong>Part of the answer for both of these is the focusable tree, which is a structure of <code class=\"markup--code markup--p-code\">FocusableWidgets</code> culled from the widget tree.</p><p class=\"aspectRatioPlaceholder-fill\"></p><img class=\"graf-image\" src=\"https://cdn-images-1.medium.com/max/1600/1*GTxFInCV6SNur5Gyj-_6Zw.png\"><p name=\"f3cd\" id=\"f3cd\" class=\"graf graf--p graf-after--figure\">For performance, this limits the number of elements to only those that could influence the end result. Not by much, in this example, but a full UI has far more <code class=\"markup--code markup--p-code\">Widgets</code> than <code class=\"markup--code markup--p-code\">FocusableWidgets</code>.</p><p name=\"a2aa\" id=\"a2aa\" class=\"graf graf--p graf-after--p\">For correctness, this gives us a way to influence navigation structurally instead of just spatially. If we always want the <code class=\"markup--code markup--p-code\">rate</code> button above to be focused first, for example, we can make the <code class=\"markup--code markup--p-code\">menu</code> a <code class=\"markup--code markup--p-code\">FocusableWidget</code> container. Moving left from <code class=\"markup--code markup--p-code\">related</code> would then focus <code class=\"markup--code markup--p-code\">menu</code> instead of <code class=\"markup--code markup--p-code\">play</code>, which can then drive down focus to its children as it sees fit.</p><p name=\"82c2\" id=\"82c2\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Nearest Neighbor<br></strong>The nearest neighbor algorithm itself was also tuned for performance, and was inspired by collision detection algorithms in game programming.</p><ol class=\"postList\"><li name=\"862e\" id=\"862e\" class=\"graf graf--li graf-after--p\">Provide the current element and its focusable siblings from the focusable tree</li><li name=\"db75\" id=\"db75\" class=\"graf graf--li graf-after--li\">Filter out elements that don&#8217;t lie within a frustum extending in the direction of the keypress</li><li name=\"ead5\" id=\"ead5\" class=\"graf graf--li graf-after--li\">Determine the Minkowski difference box between each element and the focused element</li><li name=\"3fe7\" id=\"3fe7\" class=\"graf graf--li graf-after--li\">Find the shortest vector from the origin to each box</li><li name=\"cded\" id=\"cded\" class=\"graf graf--li graf-after--li\">Select the closest element with the smallest vector to focus</li><li name=\"469f\" id=\"469f\" class=\"graf graf--li graf-after--li\">If nothing is found, we repeat the algorithm recursively with the current element&#8217;s parent</li></ol><p class=\"aspectRatioPlaceholder-fill\"></p><img class=\"graf-image\" src=\"https://cdn-images-1.medium.com/max/1600/1*_Vrugt-gpqoAgRPR1YtmBQ.png\"><h4 name=\"a1c0\" id=\"a1c0\" class=\"graf graf--h4 graf-after--figure\">Focus Requests</h4><p name=\"2a10\" id=\"2a10\" class=\"graf graf--p graf-after--h4\">Spatial navigation just finds the right element to focus, so we don&#8217;t need any fancy algorithms for pointer&#8202;&#8212;&#8202;we can just use the <code class=\"markup--code markup--p-code\">FocusableWidget</code> the mouse is over. We also save the last focused element so that the focused element can be reset when switching to LRUD mode, making the LRUD/pointer switch a breeze. In all cases, once we have a target element, we can emit a focus request.</p><p name=\"dc3d\" id=\"dc3d\" class=\"graf graf--p graf-after--p\">Once a target is established, a focus request is emitted with the <code class=\"markup--code markup--p-code\">focusPath</code>. This event is handled by the root of the application, which saves the path as part of our application state. This kicks off a new top-down render, communicating the <code class=\"markup--code markup--p-code\">focusPath</code> downward to designate the path to the component that should receive focus.</p><p name=\"8b28\" id=\"8b28\" class=\"graf graf--p graf-after--p\">We use a Higher Order Component to convert the path into helpful props (like <code class=\"markup--code markup--p-code\">focused</code> and <code class=\"markup--code markup--p-code\">entered</code>) so that components can modify their visual styles as necessary, and ultimately assign focus to the proper <code class=\"markup--code markup--p-code\">FocusableWidget</code>.</p><h4 name=\"dccd\" id=\"dccd\" class=\"graf graf--h4 graf-after--p\">Impact</h4><p name=\"3a7c\" id=\"3a7c\" class=\"graf graf--p graf-after--h4\">With these systems working together, UI developers could compose dynamic views without building custom navigation logic. Less customization means a more consistent UX and a single place to fix problems, avoiding regressions.</p><p name=\"4a78\" id=\"4a78\" class=\"graf graf--p graf-after--p\">Allowing components to utilize a single source of truth (the <code class=\"markup--code markup--p-code\">focusPath</code>) avoids issues where individual components try to focus or relinquish focus out of turn. Centralizing the assignment of focus enables validation to find bugs early and provide clear messaging to the developer.</p><h3 name=\"b219\" id=\"b219\" class=\"graf graf--h3 graf-after--p\">From Prototype to&#160;Product</h3><p name=\"9900\" id=\"9900\" class=\"graf graf--p graf-after--h3\">We built and tested these systems with a simple UI in an odd layout and a handful of different focusable tree configurations. It was pretty amazing to see LRUD and pointer working perfectly together without a single line of code customizing the navigation. We use it today on millions of TV devices ranging from streaming sticks to high-end game consoles.</p><p name=\"c2ce\" id=\"c2ce\" class=\"graf graf--p graf-after--p graf--trailing\">Does this spark your interest, or do you have a better idea for handling TV input? <a href=\"https://jobs.netflix.com/jobs?location=all&amp;organization=Engineering&amp;team=UI%20Engineering\" class=\"markup--anchor markup--p-anchor\" rel=\"nofollow noopener\" target=\"_blank\">Join us</a>, and help us make the Netflix experience even better!</p></div>","title":"Pass the Remote: User Input on TV Devices – Netflix TechBlog – Medium"}},"pageContext":{"id":"5b93830287be056953db7e18"}}